/* tslint:disable */
/* eslint-disable */
/**
 * Gentrace API
 * These API routes are designed to ingest events from clients.
 *
 * The version of the OpenAPI document: 0.27.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "../configuration";
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
import axiosWithOptionalFetch from "../axios-instance";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base";
// @ts-ignore
import { CreateDatasetV2 } from "../models";
// @ts-ignore
import { CreateFeedbackV2 } from "../models";
// @ts-ignore
import { DatasetV2 } from "../models";
// @ts-ignore
import { FeedbackV2 } from "../models";
// @ts-ignore
import { FilterableMetadataInputValue } from "../models";
// @ts-ignore
import { FolderV2 } from "../models";
// @ts-ignore
import { RunV2 } from "../models";
// @ts-ignore
import { SearchableStringInput } from "../models";
// @ts-ignore
import { SearchableUnixSecondsInput } from "../models";
// @ts-ignore
import { TestCaseV2 } from "../models";
// @ts-ignore
import { UpdateDatasetV2 } from "../models";
// @ts-ignore
import { UpdateFeedbackV2 } from "../models";
// @ts-ignore
import { V2DatasetsGet200Response } from "../models";
// @ts-ignore
import { V2EvaluationsBulkPost200Response } from "../models";
// @ts-ignore
import { V2EvaluationsBulkPostRequest } from "../models";
// @ts-ignore
import { V2EvaluationsGet200Response } from "../models";
// @ts-ignore
import { V2EvaluatorsGet200Response } from "../models";
// @ts-ignore
import { V2FoldersGet200Response } from "../models";
// @ts-ignore
import { V2PipelinesGet200Response } from "../models";
// @ts-ignore
import { V2PipelinesGet200Response1 } from "../models";
// @ts-ignore
import { V2TestCasesGet200Response } from "../models";
// @ts-ignore
import { V2TestCasesIdDelete200Response } from "../models";
// @ts-ignore
import { V2TestResultsGet200Response } from "../models";
/**
 * V2Api - axios parameter creator
 * @export
 */
export const V2ApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary List datasets
     * @param {string} [pipelineSlug] The slug of the pipeline to filter datasets by
     * @param {string} [pipelineId] The ID of the pipeline to filter datasets by
     * @param {boolean} [archived] Filter datasets by archived status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DatasetsGet: async (
      pipelineSlug?: string,
      pipelineId?: string,
      archived?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/datasets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pipelineSlug !== undefined) {
        localVarQueryParameter["pipelineSlug"] = pipelineSlug;
      }

      if (pipelineId !== undefined) {
        localVarQueryParameter["pipelineId"] = pipelineId;
      }

      if (archived !== undefined) {
        localVarQueryParameter["archived"] = archived;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a single dataset
     * @param {string} id The ID of the dataset to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DatasetsIdGet: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("v2DatasetsIdGet", "id", id);
      const localVarPath = `/v2/datasets/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a dataset
     * @param {string} id The ID of the dataset to update
     * @param {UpdateDatasetV2} updateDatasetV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DatasetsIdPost: async (
      id: string,
      updateDatasetV2: UpdateDatasetV2,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("v2DatasetsIdPost", "id", id);
      // verify required parameter 'updateDatasetV2' is not null or undefined
      assertParamExists("v2DatasetsIdPost", "updateDatasetV2", updateDatasetV2);
      const localVarPath = `/v2/datasets/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateDatasetV2,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new dataset
     * @param {CreateDatasetV2} createDatasetV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DatasetsPost: async (
      createDatasetV2: CreateDatasetV2,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createDatasetV2' is not null or undefined
      assertParamExists("v2DatasetsPost", "createDatasetV2", createDatasetV2);
      const localVarPath = `/v2/datasets`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createDatasetV2,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Bulk create evaluations
     * @param {V2EvaluationsBulkPostRequest} v2EvaluationsBulkPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2EvaluationsBulkPost: async (
      v2EvaluationsBulkPostRequest: V2EvaluationsBulkPostRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'v2EvaluationsBulkPostRequest' is not null or undefined
      assertParamExists(
        "v2EvaluationsBulkPost",
        "v2EvaluationsBulkPostRequest",
        v2EvaluationsBulkPostRequest,
      );
      const localVarPath = `/v2/evaluations/bulk`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        v2EvaluationsBulkPostRequest,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get evaluations
     * @param {string} resultId The ID of the result to get evaluations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2EvaluationsGet: async (
      resultId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'resultId' is not null or undefined
      assertParamExists("v2EvaluationsGet", "resultId", resultId);
      const localVarPath = `/v2/evaluations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (resultId !== undefined) {
        localVarQueryParameter["resultId"] = resultId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get evaluators for a given pipeline
     * @summary Get evaluators
     * @param {string} [pipelineId] The ID of the Pipeline to retrieve evaluators for. Use \&quot;null\&quot; to retrieve the organization\&#39;s evaluator templates.
     * @param {string} [pipelineSlug] Or, the slug of the Pipeline to retrieve evaluators for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2EvaluatorsGet: async (
      pipelineId?: string,
      pipelineSlug?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/evaluators`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pipelineId !== undefined) {
        localVarQueryParameter["pipelineId"] = pipelineId;
      }

      if (pipelineSlug !== undefined) {
        localVarQueryParameter["pipelineSlug"] = pipelineSlug;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get feedback
     * @param {string} id Feedback ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FeedbackIdGet: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("v2FeedbackIdGet", "id", id);
      const localVarPath = `/v2/feedback/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update feedback
     * @param {string} id Feedback ID
     * @param {UpdateFeedbackV2} updateFeedbackV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FeedbackIdPatch: async (
      id: string,
      updateFeedbackV2: UpdateFeedbackV2,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("v2FeedbackIdPatch", "id", id);
      // verify required parameter 'updateFeedbackV2' is not null or undefined
      assertParamExists(
        "v2FeedbackIdPatch",
        "updateFeedbackV2",
        updateFeedbackV2,
      );
      const localVarPath = `/v2/feedback/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateFeedbackV2,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create feedback
     * @param {CreateFeedbackV2} createFeedbackV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FeedbackPost: async (
      createFeedbackV2: CreateFeedbackV2,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createFeedbackV2' is not null or undefined
      assertParamExists("v2FeedbackPost", "createFeedbackV2", createFeedbackV2);
      const localVarPath = `/v2/feedback`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createFeedbackV2,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get folders
     * @param {string} [parentFolderId] The parent folder ID to filter folders by. Null filters to root folder. Absent will return all folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FoldersGet: async (
      parentFolderId?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/folders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (parentFolderId !== undefined) {
        localVarQueryParameter["parentFolderId"] = parentFolderId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a folder
     * @param {string} id The ID of the folder to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FoldersIdGet: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("v2FoldersIdGet", "id", id);
      const localVarPath = `/v2/folders/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get pipelines
     * @param {string} [label] The label to filter pipelines by
     * @param {SearchableStringInput} [slug] The slug to filter pipelines by
     * @param {string} [folderId] The folder ID to filter pipelines by. Null filters to root folder. Absent will return all folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2PipelinesGet: async (
      label?: string,
      slug?: SearchableStringInput,
      folderId?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/pipelines`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (label !== undefined) {
        localVarQueryParameter["label"] = label;
      }

      if (slug !== undefined) {
        localVarQueryParameter["slug"] = slug;
      }

      if (folderId !== undefined) {
        localVarQueryParameter["folderId"] = folderId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a run
     * @param {string} id The ID of the run to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2RunsIdGet: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("v2RunsIdGet", "id", id);
      const localVarPath = `/v2/runs/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * At least one of datasetId, pipelineId, or pipelineSlug must be provided
     * @summary Get test cases
     * @param {string} [datasetId] The ID of the Dataset to retrieve test cases for
     * @param {string} [pipelineId] The ID of the Pipeline to retrieve test cases for
     * @param {string} [pipelineSlug] The slug of the Pipeline to retrieve test cases for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2TestCasesGet: async (
      datasetId?: string,
      pipelineId?: string,
      pipelineSlug?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/test-cases`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (datasetId !== undefined) {
        localVarQueryParameter["datasetId"] = datasetId;
      }

      if (pipelineId !== undefined) {
        localVarQueryParameter["pipelineId"] = pipelineId;
      }

      if (pipelineSlug !== undefined) {
        localVarQueryParameter["pipelineSlug"] = pipelineSlug;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a test case
     * @param {string} id The ID of the test case to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2TestCasesIdDelete: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("v2TestCasesIdDelete", "id", id);
      const localVarPath = `/v2/test-cases/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a test case
     * @param {string} id The ID of the test case to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2TestCasesIdGet: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("v2TestCasesIdGet", "id", id);
      const localVarPath = `/v2/test-cases/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get test results
     * @param {string} [pipelineId] The ID of the pipeline
     * @param {string} [pipelineSlug] The slug of the pipeline
     * @param {SearchableUnixSecondsInput} [createdAt] Criteria to search by creation date
     * @param {{ [key: string]: FilterableMetadataInputValue; }} [metadata] Criteria to search by metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2TestResultsGet: async (
      pipelineId?: string,
      pipelineSlug?: string,
      createdAt?: SearchableUnixSecondsInput,
      metadata?: { [key: string]: FilterableMetadataInputValue },
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/test-results`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (pipelineId !== undefined) {
        localVarQueryParameter["pipelineId"] = pipelineId;
      }

      if (pipelineSlug !== undefined) {
        localVarQueryParameter["pipelineSlug"] = pipelineSlug;
      }

      if (createdAt !== undefined) {
        localVarQueryParameter["createdAt"] = createdAt;
      }

      if (metadata !== undefined) {
        localVarQueryParameter["metadata"] = metadata;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * V2Api - functional programming interface
 * @export
 */
export const V2ApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = V2ApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary List datasets
     * @param {string} [pipelineSlug] The slug of the pipeline to filter datasets by
     * @param {string} [pipelineId] The ID of the pipeline to filter datasets by
     * @param {boolean} [archived] Filter datasets by archived status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DatasetsGet(
      pipelineSlug?: string,
      pipelineId?: string,
      archived?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V2DatasetsGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DatasetsGet(
        pipelineSlug,
        pipelineId,
        archived,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get a single dataset
     * @param {string} id The ID of the dataset to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DatasetsIdGet(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetV2>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DatasetsIdGet(
        id,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Update a dataset
     * @param {string} id The ID of the dataset to update
     * @param {UpdateDatasetV2} updateDatasetV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DatasetsIdPost(
      id: string,
      updateDatasetV2: UpdateDatasetV2,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetV2>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v2DatasetsIdPost(
          id,
          updateDatasetV2,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Create a new dataset
     * @param {CreateDatasetV2} createDatasetV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DatasetsPost(
      createDatasetV2: CreateDatasetV2,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetV2>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2DatasetsPost(
        createDatasetV2,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Bulk create evaluations
     * @param {V2EvaluationsBulkPostRequest} v2EvaluationsBulkPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2EvaluationsBulkPost(
      v2EvaluationsBulkPostRequest: V2EvaluationsBulkPostRequest,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V2EvaluationsBulkPost200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v2EvaluationsBulkPost(
          v2EvaluationsBulkPostRequest,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get evaluations
     * @param {string} resultId The ID of the result to get evaluations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2EvaluationsGet(
      resultId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V2EvaluationsGet200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v2EvaluationsGet(resultId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Get evaluators for a given pipeline
     * @summary Get evaluators
     * @param {string} [pipelineId] The ID of the Pipeline to retrieve evaluators for. Use \&quot;null\&quot; to retrieve the organization\&#39;s evaluator templates.
     * @param {string} [pipelineSlug] Or, the slug of the Pipeline to retrieve evaluators for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2EvaluatorsGet(
      pipelineId?: string,
      pipelineSlug?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V2EvaluatorsGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2EvaluatorsGet(
        pipelineId,
        pipelineSlug,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get feedback
     * @param {string} id Feedback ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2FeedbackIdGet(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackV2>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2FeedbackIdGet(
        id,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Update feedback
     * @param {string} id Feedback ID
     * @param {UpdateFeedbackV2} updateFeedbackV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2FeedbackIdPatch(
      id: string,
      updateFeedbackV2: UpdateFeedbackV2,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackV2>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v2FeedbackIdPatch(
          id,
          updateFeedbackV2,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Create feedback
     * @param {CreateFeedbackV2} createFeedbackV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2FeedbackPost(
      createFeedbackV2: CreateFeedbackV2,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedbackV2>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2FeedbackPost(
        createFeedbackV2,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get folders
     * @param {string} [parentFolderId] The parent folder ID to filter folders by. Null filters to root folder. Absent will return all folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2FoldersGet(
      parentFolderId?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V2FoldersGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2FoldersGet(
        parentFolderId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get a folder
     * @param {string} id The ID of the folder to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2FoldersIdGet(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FolderV2>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2FoldersIdGet(
        id,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get pipelines
     * @param {string} [label] The label to filter pipelines by
     * @param {SearchableStringInput} [slug] The slug to filter pipelines by
     * @param {string} [folderId] The folder ID to filter pipelines by. Null filters to root folder. Absent will return all folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2PipelinesGet(
      label?: string,
      slug?: SearchableStringInput,
      folderId?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V2PipelinesGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2PipelinesGet(
        label,
        slug,
        folderId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get a run
     * @param {string} id The ID of the run to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2RunsIdGet(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunV2>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2RunsIdGet(
        id,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * At least one of datasetId, pipelineId, or pipelineSlug must be provided
     * @summary Get test cases
     * @param {string} [datasetId] The ID of the Dataset to retrieve test cases for
     * @param {string} [pipelineId] The ID of the Pipeline to retrieve test cases for
     * @param {string} [pipelineSlug] The slug of the Pipeline to retrieve test cases for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2TestCasesGet(
      datasetId?: string,
      pipelineId?: string,
      pipelineSlug?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V2TestCasesGet200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.v2TestCasesGet(
        datasetId,
        pipelineId,
        pipelineSlug,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Delete a test case
     * @param {string} id The ID of the test case to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2TestCasesIdDelete(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V2TestCasesIdDelete200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v2TestCasesIdDelete(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get a test case
     * @param {string} id The ID of the test case to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2TestCasesIdGet(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestCaseV2>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v2TestCasesIdGet(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @summary Get test results
     * @param {string} [pipelineId] The ID of the pipeline
     * @param {string} [pipelineSlug] The slug of the pipeline
     * @param {SearchableUnixSecondsInput} [createdAt] Criteria to search by creation date
     * @param {{ [key: string]: FilterableMetadataInputValue; }} [metadata] Criteria to search by metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2TestResultsGet(
      pipelineId?: string,
      pipelineSlug?: string,
      createdAt?: SearchableUnixSecondsInput,
      metadata?: { [key: string]: FilterableMetadataInputValue },
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<V2TestResultsGet200Response>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.v2TestResultsGet(
          pipelineId,
          pipelineSlug,
          createdAt,
          metadata,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        axiosWithOptionalFetch,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * V2Api - factory interface
 * @export
 */
export const V2ApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = V2ApiFp(configuration);
  return {
    /**
     *
     * @summary List datasets
     * @param {string} [pipelineSlug] The slug of the pipeline to filter datasets by
     * @param {string} [pipelineId] The ID of the pipeline to filter datasets by
     * @param {boolean} [archived] Filter datasets by archived status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DatasetsGet(
      pipelineSlug?: string,
      pipelineId?: string,
      archived?: boolean,
      options?: any,
    ): AxiosPromise<V2DatasetsGet200Response> {
      return localVarFp
        .v2DatasetsGet(pipelineSlug, pipelineId, archived, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a single dataset
     * @param {string} id The ID of the dataset to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DatasetsIdGet(id: string, options?: any): AxiosPromise<DatasetV2> {
      return localVarFp
        .v2DatasetsIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a dataset
     * @param {string} id The ID of the dataset to update
     * @param {UpdateDatasetV2} updateDatasetV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DatasetsIdPost(
      id: string,
      updateDatasetV2: UpdateDatasetV2,
      options?: any,
    ): AxiosPromise<DatasetV2> {
      return localVarFp
        .v2DatasetsIdPost(id, updateDatasetV2, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new dataset
     * @param {CreateDatasetV2} createDatasetV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DatasetsPost(
      createDatasetV2: CreateDatasetV2,
      options?: any,
    ): AxiosPromise<DatasetV2> {
      return localVarFp
        .v2DatasetsPost(createDatasetV2, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Bulk create evaluations
     * @param {V2EvaluationsBulkPostRequest} v2EvaluationsBulkPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2EvaluationsBulkPost(
      v2EvaluationsBulkPostRequest: V2EvaluationsBulkPostRequest,
      options?: any,
    ): AxiosPromise<V2EvaluationsBulkPost200Response> {
      return localVarFp
        .v2EvaluationsBulkPost(v2EvaluationsBulkPostRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get evaluations
     * @param {string} resultId The ID of the result to get evaluations for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2EvaluationsGet(
      resultId: string,
      options?: any,
    ): AxiosPromise<V2EvaluationsGet200Response> {
      return localVarFp
        .v2EvaluationsGet(resultId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get evaluators for a given pipeline
     * @summary Get evaluators
     * @param {string} [pipelineId] The ID of the Pipeline to retrieve evaluators for. Use \&quot;null\&quot; to retrieve the organization\&#39;s evaluator templates.
     * @param {string} [pipelineSlug] Or, the slug of the Pipeline to retrieve evaluators for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2EvaluatorsGet(
      pipelineId?: string,
      pipelineSlug?: string,
      options?: any,
    ): AxiosPromise<V2EvaluatorsGet200Response> {
      return localVarFp
        .v2EvaluatorsGet(pipelineId, pipelineSlug, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get feedback
     * @param {string} id Feedback ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FeedbackIdGet(id: string, options?: any): AxiosPromise<FeedbackV2> {
      return localVarFp
        .v2FeedbackIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update feedback
     * @param {string} id Feedback ID
     * @param {UpdateFeedbackV2} updateFeedbackV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FeedbackIdPatch(
      id: string,
      updateFeedbackV2: UpdateFeedbackV2,
      options?: any,
    ): AxiosPromise<FeedbackV2> {
      return localVarFp
        .v2FeedbackIdPatch(id, updateFeedbackV2, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create feedback
     * @param {CreateFeedbackV2} createFeedbackV2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FeedbackPost(
      createFeedbackV2: CreateFeedbackV2,
      options?: any,
    ): AxiosPromise<FeedbackV2> {
      return localVarFp
        .v2FeedbackPost(createFeedbackV2, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get folders
     * @param {string} [parentFolderId] The parent folder ID to filter folders by. Null filters to root folder. Absent will return all folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FoldersGet(
      parentFolderId?: string,
      options?: any,
    ): AxiosPromise<V2FoldersGet200Response> {
      return localVarFp
        .v2FoldersGet(parentFolderId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a folder
     * @param {string} id The ID of the folder to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2FoldersIdGet(id: string, options?: any): AxiosPromise<FolderV2> {
      return localVarFp
        .v2FoldersIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get pipelines
     * @param {string} [label] The label to filter pipelines by
     * @param {SearchableStringInput} [slug] The slug to filter pipelines by
     * @param {string} [folderId] The folder ID to filter pipelines by. Null filters to root folder. Absent will return all folders.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2PipelinesGet(
      label?: string,
      slug?: SearchableStringInput,
      folderId?: string,
      options?: any,
    ): AxiosPromise<V2PipelinesGet200Response> {
      return localVarFp
        .v2PipelinesGet(label, slug, folderId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a run
     * @param {string} id The ID of the run to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2RunsIdGet(id: string, options?: any): AxiosPromise<RunV2> {
      return localVarFp
        .v2RunsIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * At least one of datasetId, pipelineId, or pipelineSlug must be provided
     * @summary Get test cases
     * @param {string} [datasetId] The ID of the Dataset to retrieve test cases for
     * @param {string} [pipelineId] The ID of the Pipeline to retrieve test cases for
     * @param {string} [pipelineSlug] The slug of the Pipeline to retrieve test cases for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2TestCasesGet(
      datasetId?: string,
      pipelineId?: string,
      pipelineSlug?: string,
      options?: any,
    ): AxiosPromise<V2TestCasesGet200Response> {
      return localVarFp
        .v2TestCasesGet(datasetId, pipelineId, pipelineSlug, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a test case
     * @param {string} id The ID of the test case to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2TestCasesIdDelete(
      id: string,
      options?: any,
    ): AxiosPromise<V2TestCasesIdDelete200Response> {
      return localVarFp
        .v2TestCasesIdDelete(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a test case
     * @param {string} id The ID of the test case to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2TestCasesIdGet(id: string, options?: any): AxiosPromise<TestCaseV2> {
      return localVarFp
        .v2TestCasesIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get test results
     * @param {string} [pipelineId] The ID of the pipeline
     * @param {string} [pipelineSlug] The slug of the pipeline
     * @param {SearchableUnixSecondsInput} [createdAt] Criteria to search by creation date
     * @param {{ [key: string]: FilterableMetadataInputValue; }} [metadata] Criteria to search by metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2TestResultsGet(
      pipelineId?: string,
      pipelineSlug?: string,
      createdAt?: SearchableUnixSecondsInput,
      metadata?: { [key: string]: FilterableMetadataInputValue },
      options?: any,
    ): AxiosPromise<V2TestResultsGet200Response> {
      return localVarFp
        .v2TestResultsGet(
          pipelineId,
          pipelineSlug,
          createdAt,
          metadata,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * V2Api - object-oriented interface
 * @export
 * @class V2Api
 * @extends {BaseAPI}
 */
export class V2Api extends BaseAPI {
  /**
   *
   * @summary List datasets
   * @param {string} [pipelineSlug] The slug of the pipeline to filter datasets by
   * @param {string} [pipelineId] The ID of the pipeline to filter datasets by
   * @param {boolean} [archived] Filter datasets by archived status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2DatasetsGet(
    pipelineSlug?: string,
    pipelineId?: string,
    archived?: boolean,
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2DatasetsGet(pipelineSlug, pipelineId, archived, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a single dataset
   * @param {string} id The ID of the dataset to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2DatasetsIdGet(id: string, options?: AxiosRequestConfig) {
    return V2ApiFp(this.configuration)
      .v2DatasetsIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a dataset
   * @param {string} id The ID of the dataset to update
   * @param {UpdateDatasetV2} updateDatasetV2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2DatasetsIdPost(
    id: string,
    updateDatasetV2: UpdateDatasetV2,
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2DatasetsIdPost(id, updateDatasetV2, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new dataset
   * @param {CreateDatasetV2} createDatasetV2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2DatasetsPost(
    createDatasetV2: CreateDatasetV2,
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2DatasetsPost(createDatasetV2, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Bulk create evaluations
   * @param {V2EvaluationsBulkPostRequest} v2EvaluationsBulkPostRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2EvaluationsBulkPost(
    v2EvaluationsBulkPostRequest: V2EvaluationsBulkPostRequest,
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2EvaluationsBulkPost(v2EvaluationsBulkPostRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get evaluations
   * @param {string} resultId The ID of the result to get evaluations for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2EvaluationsGet(resultId: string, options?: AxiosRequestConfig) {
    return V2ApiFp(this.configuration)
      .v2EvaluationsGet(resultId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get evaluators for a given pipeline
   * @summary Get evaluators
   * @param {string} [pipelineId] The ID of the Pipeline to retrieve evaluators for. Use \&quot;null\&quot; to retrieve the organization\&#39;s evaluator templates.
   * @param {string} [pipelineSlug] Or, the slug of the Pipeline to retrieve evaluators for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2EvaluatorsGet(
    pipelineId?: string,
    pipelineSlug?: string,
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2EvaluatorsGet(pipelineId, pipelineSlug, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get feedback
   * @param {string} id Feedback ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2FeedbackIdGet(id: string, options?: AxiosRequestConfig) {
    return V2ApiFp(this.configuration)
      .v2FeedbackIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update feedback
   * @param {string} id Feedback ID
   * @param {UpdateFeedbackV2} updateFeedbackV2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2FeedbackIdPatch(
    id: string,
    updateFeedbackV2: UpdateFeedbackV2,
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2FeedbackIdPatch(id, updateFeedbackV2, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create feedback
   * @param {CreateFeedbackV2} createFeedbackV2
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2FeedbackPost(
    createFeedbackV2: CreateFeedbackV2,
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2FeedbackPost(createFeedbackV2, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get folders
   * @param {string} [parentFolderId] The parent folder ID to filter folders by. Null filters to root folder. Absent will return all folders.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2FoldersGet(parentFolderId?: string, options?: AxiosRequestConfig) {
    return V2ApiFp(this.configuration)
      .v2FoldersGet(parentFolderId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a folder
   * @param {string} id The ID of the folder to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2FoldersIdGet(id: string, options?: AxiosRequestConfig) {
    return V2ApiFp(this.configuration)
      .v2FoldersIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get pipelines
   * @param {string} [label] The label to filter pipelines by
   * @param {SearchableStringInput} [slug] The slug to filter pipelines by
   * @param {string} [folderId] The folder ID to filter pipelines by. Null filters to root folder. Absent will return all folders.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2PipelinesGet(
    label?: string,
    slug?: SearchableStringInput,
    folderId?: string,
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2PipelinesGet(label, slug, folderId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a run
   * @param {string} id The ID of the run to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2RunsIdGet(id: string, options?: AxiosRequestConfig) {
    return V2ApiFp(this.configuration)
      .v2RunsIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * At least one of datasetId, pipelineId, or pipelineSlug must be provided
   * @summary Get test cases
   * @param {string} [datasetId] The ID of the Dataset to retrieve test cases for
   * @param {string} [pipelineId] The ID of the Pipeline to retrieve test cases for
   * @param {string} [pipelineSlug] The slug of the Pipeline to retrieve test cases for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2TestCasesGet(
    datasetId?: string,
    pipelineId?: string,
    pipelineSlug?: string,
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2TestCasesGet(datasetId, pipelineId, pipelineSlug, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a test case
   * @param {string} id The ID of the test case to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2TestCasesIdDelete(id: string, options?: AxiosRequestConfig) {
    return V2ApiFp(this.configuration)
      .v2TestCasesIdDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a test case
   * @param {string} id The ID of the test case to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2TestCasesIdGet(id: string, options?: AxiosRequestConfig) {
    return V2ApiFp(this.configuration)
      .v2TestCasesIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get test results
   * @param {string} [pipelineId] The ID of the pipeline
   * @param {string} [pipelineSlug] The slug of the pipeline
   * @param {SearchableUnixSecondsInput} [createdAt] Criteria to search by creation date
   * @param {{ [key: string]: FilterableMetadataInputValue; }} [metadata] Criteria to search by metadata
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof V2Api
   */
  public v2TestResultsGet(
    pipelineId?: string,
    pipelineSlug?: string,
    createdAt?: SearchableUnixSecondsInput,
    metadata?: { [key: string]: FilterableMetadataInputValue },
    options?: AxiosRequestConfig,
  ) {
    return V2ApiFp(this.configuration)
      .v2TestResultsGet(pipelineId, pipelineSlug, createdAt, metadata, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
